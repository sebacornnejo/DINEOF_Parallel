import os
import sys
import subprocess
import netCDF4
import shutil


def generate_dineof_init(input_file, output_dir="Output"):
    """
    Generates dineof.init configuration file based on input NetCDF metadata.
    """
    try:
        with netCDF4.Dataset(input_file, "r") as nc:
            # Extract dimensions
            time_dim = len(nc.dimensions["time"]) if "time" in nc.dimensions else 0
            lat_dim = len(nc.dimensions["lat"])
            lon_dim = len(nc.dimensions["lon"])

            print(f"Input dimensions: time={time_dim}, lat={lat_dim}, lon={lon_dim}")

            # Check for variables
            if "chlor_a" not in nc.variables:
                raise ValueError("Variable 'chlor_a' not found in input file.")

            # Determine mask
            # Assuming mask is in the same file or we use the data itself as mask (NaNs)
            # The user mentioned 'mask' variable exists in the file.
            mask_file = f"['{os.path.basename(input_file)}#mask']"
            data_file = f"['{os.path.basename(input_file)}#chlor_a']"

            # Determine output filename
            output_filename = f"{output_dir}/dineof_{os.path.basename(input_file)}"

            # Configuration content
            config = f"""! DINEOF configuration generated by run_dineof.py
data = {data_file}
mask = {mask_file}
! time = 'dates.dat' ! Optional: if you have a date file
alpha = 0.01
numit = 3
nev = {min(100, time_dim // 2)} ! Adaptive number of modes
neini = 1
ncv = {min(100, time_dim // 2) + 5}
tol = 1.0e-8
nitemax = 300
toliter = 1.0e-3
rec = 1
eof = 1
norm = 0
Output = '{output_dir}/'
results = ['{output_filename}']
seed = 243435
"""
            return config
    except Exception as e:
        print(f"Error reading NetCDF file: {e}")
        sys.exit(1)


def windows_to_wsl_path(win_path):
    """Converts a Windows path to a WSL path."""
    drive, tail = os.path.splitdrive(win_path)
    drive_letter = drive.lower().replace(":", "")
    wsl_path = f"/mnt/{drive_letter}{tail.replace(os.sep, '/')}"
    return wsl_path


import argparse
import numpy as np
import time


def crop_netcdf(input_file, output_file, lat_range, lon_range):
    """
    Crops a NetCDF file to the specified latitude and longitude range.
    lat_range: (min_lat, max_lat)
    lon_range: (min_lon, max_lon)
    """
    print(f"Cropping {input_file} to Lat: {lat_range}, Lon: {lon_range}...", flush=True)
    try:
        with netCDF4.Dataset(input_file, "r") as src, netCDF4.Dataset(
            output_file, "w"
        ) as dst:
            # Copy global attributes
            dst.setncatts(src.__dict__)

            # Get dimensions and variables
            lat_var = src.variables["lat"][:]
            lon_var = src.variables["lon"][:]

            # Find indices
            lat_indices = np.where(
                (lat_var >= lat_range[0]) & (lat_var <= lat_range[1])
            )[0]
            lon_indices = np.where(
                (lon_var >= lon_range[0]) & (lon_var <= lon_range[1])
            )[0]

            if len(lat_indices) == 0 or len(lon_indices) == 0:
                raise ValueError("No data found in the specified range.")

            lat_min_idx, lat_max_idx = lat_indices[0], lat_indices[-1] + 1
            lon_min_idx, lon_max_idx = lon_indices[0], lon_indices[-1] + 1

            print(
                f"Cropping indices - Lat: {lat_min_idx}:{lat_max_idx}, Lon: {lon_min_idx}:{lon_max_idx}"
            )

            # Create dimensions
            for name, dimension in src.dimensions.items():
                if name == "lat":
                    dst.createDimension(name, len(lat_indices))
                elif name == "lon":
                    dst.createDimension(name, len(lon_indices))
                else:
                    dst.createDimension(
                        name, (len(dimension) if not dimension.isunlimited() else None)
                    )

            # Copy variables (skip mask, handle it separately)
            for name, variable in src.variables.items():
                if name == "mask":
                    continue  # Handle mask separately after

                x = dst.createVariable(
                    name,
                    variable.datatype,
                    variable.dimensions,
                    fill_value=getattr(variable, "_FillValue", None),
                )
                dst[name].setncatts(src[name].__dict__)

                if name == "lat":
                    dst[name][:] = src[name][lat_min_idx:lat_max_idx]
                elif name == "lon":
                    dst[name][:] = src[name][lon_min_idx:lon_max_idx]
                elif name == "chlor_a":
                    # Assuming dimensions are (time, lat, lon)
                    dims = variable.dimensions
                    if dims == ("time", "lat", "lon"):
                        dst[name][:, :, :] = src[name][
                            :, lat_min_idx:lat_max_idx, lon_min_idx:lon_max_idx
                        ]
                    elif dims == ("lat", "lon"):
                        dst[name][:, :] = src[name][
                            lat_min_idx:lat_max_idx, lon_min_idx:lon_max_idx
                        ]
                    elif dims == ("time",):
                        dst[name][:] = src[name][:]
                    else:
                        print(
                            f"Warning: Copying variable {name} directly (check dimensions)."
                        )
                        dst[name][:] = src[name][:]
                else:
                    dst[name][:] = src[name][:]

            # Now handle mask specially - create as 2D
            if "mask" in src.variables:
                mask_var = src.variables["mask"]
                dims = mask_var.dimensions
                if dims == ("time", "lat", "lon"):
                    # Create 2D mask variable
                    mask_2d_var = dst.createVariable(
                        "mask",
                        mask_var.datatype,
                        ("lat", "lon"),
                        fill_value=getattr(mask_var, "_FillValue", None),
                    )
                    # Copy attributes
                    for attr in mask_var.ncattrs():
                        if attr not in ["_FillValue"]:
                            mask_2d_var.setncattr(attr, mask_var.getncattr(attr))

                    # Aggregate 3D mask to 2D
                    mask_3d = src.variables["mask"][
                        :, lat_min_idx:lat_max_idx, lon_min_idx:lon_max_idx
                    ]
                    mask_2d = np.max(mask_3d, axis=0).astype(mask_var.datatype)
                    mask_2d_var[:, :] = mask_2d
                    print(f"Converted mask from 3D {dims} to 2D (lat, lon)")
                elif dims == ("lat", "lon"):
                    # Already 2D, just crop
                    mask_2d_var = dst.createVariable(
                        "mask",
                        mask_var.datatype,
                        ("lat", "lon"),
                        fill_value=getattr(mask_var, "_FillValue", None),
                    )
                    mask_2d_var.setncatts(mask_var.__dict__)
                    mask_2d_var[:, :] = src.variables["mask"][
                        lat_min_idx:lat_max_idx, lon_min_idx:lon_max_idx
                    ]
                else:
                    print(f"Warning: Unexpected mask dimensions {dims}")

        print(f"Cropped file saved to {output_file}")
        return True

    except Exception as e:
        print(f"Error cropping NetCDF: {e}")
        return False


def convert_mask_3d_to_2d(input_file, output_file):
    """
    Converts a 3D mask (time, lat, lon) to 2D (lat, lon) in a NetCDF file.
    """
    print(f"Converting 3D mask to 2D in {input_file}...", flush=True)
    try:
        with netCDF4.Dataset(input_file, "r") as src, netCDF4.Dataset(
            output_file, "w"
        ) as dst:
            # Copy global attributes
            dst.setncatts(src.__dict__)

            # Create dimensions
            for name, dimension in src.dimensions.items():
                dst.createDimension(
                    name, (len(dimension) if not dimension.isunlimited() else None)
                )

            # Copy all variables except mask
            for name, variable in src.variables.items():
                if name == "mask":
                    continue  # Handle mask separately

                x = dst.createVariable(
                    name,
                    variable.datatype,
                    variable.dimensions,
                    fill_value=getattr(variable, "_FillValue", None),
                )
                dst[name].setncatts(src[name].__dict__)
                dst[name][:] = src[name][:]

            # Handle mask specially - convert 3D to 2D
            if "mask" in src.variables:
                mask_var = src.variables["mask"]
                dims = mask_var.dimensions
                if dims == ("time", "lat", "lon"):
                    # Create 2D mask variable
                    mask_2d_var = dst.createVariable(
                        "mask",
                        mask_var.datatype,
                        ("lat", "lon"),
                        fill_value=getattr(mask_var, "_FillValue", None),
                    )
                    # Copy attributes
                    for attr in mask_var.ncattrs():
                        if attr not in ["_FillValue"]:
                            mask_2d_var.setncattr(attr, mask_var.getncattr(attr))

                    # Aggregate 3D mask to 2D (take max over time)
                    mask_3d = src.variables["mask"][:]
                    mask_2d = np.max(mask_3d, axis=0).astype(mask_var.datatype)
                    mask_2d_var[:, :] = mask_2d
                    print(f"Converted mask from 3D {dims} to 2D (lat, lon)")
                elif dims == ("lat", "lon"):
                    # Already 2D, just copy
                    mask_2d_var = dst.createVariable(
                        "mask",
                        mask_var.datatype,
                        ("lat", "lon"),
                        fill_value=getattr(mask_var, "_FillValue", None),
                    )
                    mask_2d_var.setncatts(mask_var.__dict__)
                    mask_2d_var[:, :] = src.variables["mask"][:, :]
                    print("Mask is already 2D, copied as-is")
                else:
                    print(f"Warning: Unexpected mask dimensions {dims}")

        print(f"Converted file saved to {output_file}")
        return True

    except Exception as e:
        print(f"Error converting mask: {e}")
        import traceback

        traceback.print_exc()
        return False


def main():
    parser = argparse.ArgumentParser(description="Automate DINEOF execution.")
    parser.add_argument("input_file", help="Input NetCDF file")
    parser.add_argument(
        "--crop",
        nargs=4,
        type=float,
        metavar=("S", "N", "W", "E"),
        help="Crop region: South North West East (e.g. -55 -49 -69 -63)",
    )

    args = parser.parse_args()
    input_file_path = args.input_file

    if not os.path.exists(input_file_path):
        print(f"Error: File {input_file_path} not found.")
        sys.exit(1)

    # Absolute path for safety
    input_file_abs = os.path.abspath(input_file_path)
    base_dir = os.path.dirname(os.path.abspath(__file__))
    dineof_dir = os.path.join(base_dir, "DINEOF-2.0.0")

    # Handle cropping or mask conversion
    if args.crop:
        south, north, west, east = args.crop
        output_cropped = (
            os.path.splitext(input_file_abs)[0] + f"_cropped_{int(time.time())}.nc"
        )
        success = crop_netcdf(
            input_file_abs, output_cropped, (south, north), (west, east)
        )
        if not success:
            sys.exit(1)
        input_file_abs = output_cropped
        print(f"Using cropped file: {input_file_abs}")
    else:
        # Check if mask needs conversion (3D to 2D)
        with netCDF4.Dataset(input_file_abs, "r") as nc:
            if "mask" in nc.variables:
                mask_dims = nc.variables["mask"].dimensions
                if mask_dims == ("time", "lat", "lon"):
                    # Check if a converted file already exists
                    base_name = os.path.splitext(input_file_abs)[0]
                    existing_mask2d = None

                    # Look for existing mask2d files
                    dir_path = os.path.dirname(input_file_abs)
                    base_filename = os.path.basename(base_name)
                    for file in os.listdir(dir_path):
                        if file.startswith(
                            base_filename + "_mask2d_"
                        ) and file.endswith(".nc"):
                            candidate = os.path.join(dir_path, file)
                            # Verify it has a 2D mask
                            try:
                                with netCDF4.Dataset(candidate, "r") as check_nc:
                                    if "mask" in check_nc.variables:
                                        check_dims = check_nc.variables[
                                            "mask"
                                        ].dimensions
                                        if check_dims == ("lat", "lon"):
                                            existing_mask2d = candidate
                                            break
                            except:
                                continue

                    if existing_mask2d:
                        print(f"Found existing converted mask file: {existing_mask2d}")
                        input_file_abs = existing_mask2d
                        print(f"Using converted file: {input_file_abs}")
                    else:
                        print("3D mask detected, converting to 2D...")
                        output_converted = (
                            os.path.splitext(input_file_abs)[0]
                            + f"_mask2d_{int(time.time())}.nc"
                        )
                        success = convert_mask_3d_to_2d(
                            input_file_abs, output_converted
                        )
                        if not success:
                            sys.exit(1)
                        input_file_abs = output_converted
                        print(f"Using converted file: {input_file_abs}")

    # Ensure output directory exists
    output_dir = os.path.join(dineof_dir, "Output")
    os.makedirs(output_dir, exist_ok=True)

    # Generate config
    print("Generating dineof.init...")

    # Read metadata
    try:
        with netCDF4.Dataset(input_file_abs, "r") as nc:
            time_dim = len(nc.dimensions["time"]) if "time" in nc.dimensions else 0
            lat_dim = len(nc.dimensions["lat"])
            lon_dim = len(nc.dimensions["lon"])
            print(f"Input dimensions: time={time_dim}, lat={lat_dim}, lon={lon_dim}")
            if "chlor_a" not in nc.variables:
                raise ValueError("Variable 'chlor_a' not found in input file.")

            # Check if time variable exists
            if "time" in nc.variables:
                # Use NetCDF format for time
                time_config = f"time = '{input_file_abs}#time'"
            else:
                print("Warning: 'time' variable not found. Time filtering might fail.")
                time_config = "! time = 'time_file.dat'"

    except Exception as e:
        print(f"Error reading NetCDF file: {e}")
        sys.exit(1)

    # Generate config content using absolute paths
    mask_file = f"['{input_file_abs}#mask']"
    data_file = f"['{input_file_abs}#chlor_a']"
    output_filename = f"{output_dir}/dineof_{os.path.basename(input_file_abs)}"

    config = f"""! DINEOF configuration generated by run_dineof.py
data = {data_file}
mask = {mask_file}
{time_config}
alpha = 0.01
numit = 3
nev = {min(100, time_dim // 2)}
neini = 1
ncv = {min(100, time_dim // 2) + 5}
tol = 1.0e-8
nitemax = 300
toliter = 1.0e-3
rec = 1
eof = 1
norm = 0
Output = '{output_dir}/'
results = ['{output_filename}#chlor_a']
EOF.U = ['{output_dir}/eof.nc#U']
EOF.V = '{output_dir}/eof.nc#V'
EOF.Sigma = '{output_dir}/eof.nc#Sigma'
seed = 243435
"""

    config_path = os.path.join(dineof_dir, "dineof.init")
    with open(config_path, "w") as f:
        f.write(config)

    print(f"Configuration written to {config_path}")

    # Run DINEOF
    print("Running DINEOF...")
    # Direct execution on macOS
    dineof_exe = os.path.join(dineof_dir, "dineof")
    cmd = [dineof_exe, "dineof.init"]

    try:
        subprocess.run(cmd, cwd=dineof_dir, check=True)
        print("DINEOF execution completed successfully.")
        print(f"Output file: {output_filename}")
    except subprocess.CalledProcessError as e:
        print(f"DINEOF execution failed with error code {e.returncode}")
        sys.exit(1)


if __name__ == "__main__":
    main()
